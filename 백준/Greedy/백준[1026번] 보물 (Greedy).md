# 백준[1026번] 보물 [Swift]

## 🔎 분류 : Greedy

<br><br>

🔗 [문제 원본 링크](https://www.acmicpc.net/problem/1026)
<br><br>

## 📝 문제 설명
옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.

길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.

S = A[0] × B[0] + ... + A[N-1] × B[N-1]

S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.

S의 최솟값을 출력하는 프로그램을 작성하시오.

### # 입력
첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.

### # 출력
첫째 줄에 S의 최솟값을 출력한다.
<br><br>

## 💡 해결 방법
S가 최솟값이 되는 조건은 그냥 느낌이 오셨을 수도 있어요! 저도 그냥 느낌이 왔거든요. 최대값과 최소값을 곱해주면 됩니다.<br>
a * b 에서 a가 겨우 1이라면 b가 아무리 커도 b는 곱셈의 결과는 b입니다. a가 2로 커지기만 해도 모든 값은 두배가 되구요!<br>
그래서 가장 작은 값들이 가장 큰값들을 처리해주면 가장 최소값의 결과가 나오는 겁니다!
그리디 방법중 재배열 부등식이라는걸 공부하시면 더 자세히 공부하실 수 있다고 합니다!
<br><br>

## Code 풀이
```Swift
let n = Int(readLine()!)!
var a = readLine()!.split(separator: " ").map { Int(String($0))! }
var b = readLine()!.split(separator: " ").map { Int(String($0))! }

var sum = 0

a.sort(by:>)
b.sort()

for i in 0..<n {
    sum += (a[i] * b[i])
}

print(sum)
```
