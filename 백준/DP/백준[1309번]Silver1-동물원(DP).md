# 백준[1309번]Silver1-동물원[Swift]

## 🔎 분류 : DP

<br><br>
🔗[문제 원본 링크](https://www.acmicpc.net/problem/1309)
<br><br>
## 📝 문제 설명
어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.
<img src = https://www.acmicpc.net/upload/201004/dnfl.JPG>


이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.

동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.

### 입력
첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.

### 출력
첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.
<br><br>
## 💡 해결 방법
옛날에 프로그래머스에서 풀어봤던 기억이 있는데.. 가물가물했다.
DP문제 임을 알고 있으므로 바로 또 점화식 찾기를 시작했다.
F(n)를 유도해보려고 하였으나.. 감이 잡히지 않아 F(1)부터 F(4)까지 구해보았고<br>
F(1) = 3 <br>
F(2) = 7 <br>
F(3) = 17<br>
F(4) = 41<br>
이 값속에서 규칙을 찾아보았더니.. 바로 찾아졌다..
(n-1)에 2를 곱하고 n-2와 더하면 n이 되는 규칙을 통해
F(n) = 2*F(n-1) + F(n-2)라는 점화식을 구하여 해결할 수 있었다..
이렇게 구하는게 맞나.. 더 공부하고 다른 방법도 찾아보아야겠다..

++ 다른 방법을 알아본 결과!!<br>
아까 해결했던 [RGB거리](https://www.acmicpc.net/problem/1149) 문제 처럼 2차원 dp를 생성하여 각각의 경우를 센 후 다 더하는 방식으로 구할 수 있었다..
생각해보니 겹치면 안되는 조건이 똑같다! 둘 다 해본 결과 확실히 결과는 첫 번쨰 방법이 시간 복잡도나 공간 복잡도가 더 좋긴하다!
<br><br>
## Code 풀이
```swift
let n = Int(readLine()!)!

var dp = Array(repeating: 0, count: n+1)

if n > 2 {
    for i in 3...n {
        dp[1] = 3
        dp[2] = 7
        dp[i] = (2*dp[i-1] + dp[i-2])%9901
    }
    print(dp[n])
} else {
    print(n==1 ? 3 : 7)
}
```

## 2차원 DP 코드 풀이
```swift
let n = Int(readLine()!)!

var dp = [Array](repeating: Array(repeating:0, count: 3), count: n+1)
dp[1] = [1,1,1] // 1일때는 왼쪽일 경우도 1 오른쪽일 경우도 1 없을 경우도 1 이니까 1,1,1
for i in 2...n {
    dp[i][0] = (dp[i-1][1] + dp[i-1][2]) % 9901 // 사자가 왼쪽
    dp[i][1] = (dp[i-1][0] + dp[i-1][2]) % 9901 // 사자가 오른쪽
    dp[i][2] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2]) % 9901 // 사자가 없는 경우
}

print(dp[n].reduce(0,+)%9901)

```