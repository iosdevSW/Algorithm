# 백준[15990번] 1,2,3 더하기 5 [Swift]

## 🔎 분류 : DP
<br><br>
🔗[문제 원본 링크]( )
<br><br>
## 📝 문제 설명
정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.

1+2+1
1+3
3+1
정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.

### 출력
각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.
<br><br>
## 💡 해결 방법
점화식 찾는게 너무 어려웠다. 1부터 5까지 경우의 수를 찾고 가장 뒤가 1일 경우 2일경우 3일경우로 나누어서 하면 되지 않을까? 까지는 생각해 보았지만 DP를 그럼 어떤식으로 짜야할까?? 는 생각이 들지 않아서 결국 구글링하여 방법을 찾고 이해하는 식으로 택했다.
먼저 해결방법은 이렇다.<br>
F(1)의 경우 1로 끝나는 경우 한개의 경우 밖에 없다. DP[1] = [0,1,0,0]<br>
F(2)의 경우도 2로 끝나는 경우 한가지이다. DP[2] = [0,0,1,0] <br>
F(3)의 경우는 1,<B>2 </B>의 2로 끝나는 경우 2,<B>1</B>의 1로 끝나는 경우 
<B>3</B> 3으로 끝나는 경우가 각각 1가지 이다. DP[3] = [0,1,1,1] <br>
<br>
이제 점화식을 어떻게 유도할 수 있나 알아보자!!<br>
4라는 숫자를 구할 때 (n-1)에서 +1 하면 n을 구하는 방법은
마지막에 +1을 해야 하므로 n-1의 마지막은 2 또는 3을 더해주어야 한다.<br>
그래서 dp[4][1] (4를 구하는 경우의 수에서 마지막이 1인 경우) = 3을 구할때 마지막이 2였던 경우의 수 + 3이였던 경우의 수 라는 거다!
<br>
즉 dp[4][1] = dp[3][2] + dp[3][3]<br>
그럼 마지막이 2인 경우 dp[4][2] = dp[2][1] + dp[2][3]<br>
3인 경우 dp[4][3] = dp[1][1] + dp[1][2] <br>
이를 통해 얻을 수 있는 점화식은 <br>
dp[n][1] = dp[n-1][2] + dp[n-1][3]<br>
dp[n][2] = dp[n-2][1] + dp[n-2][3]<br>
dp[n][3] = dp[n-3][1] + dp[n-3][2] <br>
이고 dp[n]이 1 2 3 의 경우를 합하면 총 경우의 수와 같다고 볼 수 있다!<br>
알고나니 어렵지 않다.. 좀 더 많은 문제를 겪어봐야겠다.
<br><br>
## Code 풀이

```Swift
var dp = [[Int]](repeating: [Int](repeating: 0, count: 4), count: 100001)
let mod = 1000000009
dp[1] = [0,1,0,0] // 1은 1로 끝나는 경우의 수 1개 뿐
dp[2] = [0,0,1,0] // 2는 2로 끝나는 경우의 수 1개 뿐
dp[3] = [0,1,1,1] // 2,1 -> 2로 끝나는 경우 1개
                  // 1,2 -> 2로 끝나는 경우 1개
                  // 3 -> 3으로 끝나는 경우 1개
for i in 4..<100001 {
    dp[i][1] = dp[i-1][2] % mod + dp[i-1][3] % mod // n-1중에 2나 3으로 끝나는 경우의 합
    dp[i][2] = dp[i-2][1] % mod + dp[i-2][3] % mod // n-2중에 1이나 3으로 끝나는 경우의 합
    dp[i][3] = dp[i-3][1] % mod + dp[i-3][2] % mod // n-3중에 1이나 2로 끝나는 경우의 합
}

let n = Int(readLine()!)!

for _ in 1...n {
    let num = Int(readLine()!)!
    print(dp[num].reduce(0, +) % mod)
}

```