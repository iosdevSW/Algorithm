# 백준[6064번] 카잉 달력 [Swift]

## 🔎 분류 : 수학 (합동연립방정식)

<br><br>

🔗 [문제 원본 링크](https://www.acmicpc.net/problem/6064)
<br><br>

## 📝 문제 설명
최근에 ICPC 탐사대는 남아메리카의 잉카 제국이 놀라운 문명을 지닌 카잉 제국을 토대로 하여 세워졌다는 사실을 발견했다. 카잉 제국의 백성들은 특이한 달력을 사용한 것으로 알려져 있다. 그들은 M과 N보다 작거나 같은 두 개의 자연수 x, y를 가지고 각 년도를 <x:y>와 같은 형식으로 표현하였다. 그들은 이 세상의 시초에 해당하는 첫 번째 해를 <1:1>로 표현하고, 두 번째 해를 <2:2>로 표현하였다. <x:y>의 다음 해를 표현한 것을 <x':y'>이라고 하자. 만일 x < M 이면 x' = x + 1이고, 그렇지 않으면 x' = 1이다. 같은 방식으로 만일 y < N이면 y' = y + 1이고, 그렇지 않으면 y' = 1이다. <M:N>은 그들 달력의 마지막 해로서, 이 해에 세상의 종말이 도래한다는 예언이 전해 온다.

예를 들어, M = 10 이고 N = 12라고 하자. 첫 번째 해는 <1:1>로 표현되고, 11번째 해는 <1:11>로 표현된다. <3:1>은 13번째 해를 나타내고, <10:12>는 마지막인 60번째 해를 나타낸다.

네 개의 정수 M, N, x와 y가 주어질 때, <M:N>이 카잉 달력의 마지막 해라고 하면 <x:y>는 몇 번째 해를 나타내는지 구하는 프로그램을 작성하라.

### # 입력
입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 한 줄로 구성된다. 각 줄에는 네 개의 정수 M, N, x와 y가 주어진다. (1 ≤ M, N ≤ 40,000, 1 ≤ x ≤ M, 1 ≤ y ≤ N) 여기서 <M:N>은 카잉 달력의 마지막 해를 나타낸다.

### # 출력
출력은 표준 출력을 사용한다. 각 테스트 데이터에 대해, 정수 k를 한 줄에 출력한다. 여기서 k는 <x:y>가 k번째 해를 나타내는 것을 의미한다. 만일 <x:y>에 의해 표현되는 해가 없다면, 즉, <x:y>가 유효하지 않은 표현이면, -1을 출력한다.
<br><br>

## 💡 해결 방법
문제 부터 이해하기 어려울 수 있는데 이 달력은 <1:1> 첫 번째 해로 시작해서 <n:m>의 마지막 해로 끝납니다. 
이 달력은 즉 i번째 해를 <n으로 나눈 나머지: m으로 나눈 나머지>로 나타내는 것 입니다!<br>
이 문제를 풀 때 1부터 n까지 for문을 돌리고 if i % n == x이고 i%m == y 를 구하면 쉽게 구하겠지만 이는 시간초과가 발생할 수 있습니다. 그렇다면 반복 횟수를 줄여야 하는데 다음의 방법을 사용할 수 있습니다.
10으로 나눌때 나머지 3이라는 것은 3에서 시작해서 10씩 더해주면 13,23 등 나머지가 3인 경우만 나타나게 됩니다.
여기서 이를 적용해서 x부터 n씩 더해주는 경우에서 m으로 나눴을때 y인 경우만 찾으면 됩니다.
<br><br>

## Code 풀이
```Swift
let N = Int(readLine()!)!

for _ in 1...N {
    let input = readLine()!.split(separator: " ").map { Int(String($0))! }
    var (n,m,x,y) = (input[0],input[1],input[2],input[3])
    if x == n { x = 0 }
    if y == m { y = 0 }
    let l = lcm(n,m)
    var ans = -1
    for i in stride(from: x, through: l, by: n) {
        if i % m == y {
            ans = i
        }
    }
    print(ans)
}

func gcd(_ a: Int, _ b: Int)->Int {
    if a == 0 { return b }
    return gcd(b%a, a)
}

func lcm(_ a: Int, _ b: Int)->Int {
    return a / gcd(a,b) * b
}
```